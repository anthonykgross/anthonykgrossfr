{% extends 'base.html.twig' %}

{% block title %}Déploiement continu avec Docker entre Gitlab et Rancher{% endblock %}
{% block description %}L'ADASS est une conférence annuelle qui se déroule sur plusieurs jours dans différentes institutions astronomiques.{% endblock %}
{% block og_url %}http://{{ app.request.host ~ path('anthonykgrossfr_page_lire', {'name' : 'deploiement-continu-docker-gitlab-rancher' }) }}{% endblock %}
{% block og_image %}http://{{ app.request.host ~  asset("bundles/anthonykgrossfrmain/images/Articles/deploiement-continu-docker-gitlab-rancher.jpg") }}{% endblock %}

{% block javascripts %}
<script type="application/ld+json" xmlns="http://www.w3.org/1999/html">
    {
        "@context": "http://schema.org",
        "@type": "NewsArticle",
        "mainEntityOfPage":{
            "@type":"WebPage",
            "@id":"{{ block("og_url") }}"
        },
        "headline": "{{ block("title") }}",
        "image": {
            "@type": "ImageObject",
            "url": "{{ block("og_image") }}",
            "height": 400,
            "width": 1200
        },
        "datePublished": "{{ "2016-11-14"|date("c") }}",
        "dateModified": "{{ "2016-11-14"|date("c") }}",
        "author": {
            "@type": "Person",
            "name": "Anthony GROSS"
        },
        "publisher": {
            "@type": "Organization",
            "name": "AnthonyKGROSS",
            "logo": {
                "@type": "ImageObject",
                "url": "http://anthonykgross.fr/images/akg-wide.png",
                "width": 80,
                "height": 60
            }
        },
        "description": "{{ block("description") }}"
    }
</script>
{% endblock %}

{% block body %}
    <div class="container">
        <section id="blog" class="single-page">
            <div class="header margin-bottom40">
                <h2>Déploiement continu avec Docker entre Gitlab et Rancher</h2>
                <p>
                    Avec la progression dans l’utilisation des containers d’application (Docker, AWS, etc …),
                    il devient de plus en plus nécessaire de passer par des gestionnaires de containers pour gérer
                    un peu tout ce chaos. Par conséquent, cette anarchie ne facilite pas la maintenance et la mise
                    en production, le déploiement, de nos applications par un être humain &ldquo;normal&rdquo;; c’est ainsi qu’on
                    en vient à automatiser le processus de déploiement. Ah bah ca comme de par exemple ?! C’est le
                    sujet de l’article !
                </p>
            </div>
            <div class="item">
                <figure>
                    <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/deploiement-continu-docker-gitlab-rancher.jpg') }}" alt="Thumbnail" />
                </figure>
            </div>
            <br/>
            <div class="row">
                <div class="span12">
                    <div class="row">
                        <div class="span8">
                            <h2>Présentation</h2>
                            <p>
                                Vous l’aurez compris : nous allons faire en sorte qu'à partir d’un simple
                                commit via Git (ici hébergé sur Gitlab.com), nous allons construire notre
                                image serveur de notre application via Docker, lancer nos tests (Oui, car
                                c'est important!) et si tout se passe bien : on balance le tout en prod’.
                                Pour faciliter la compréhension, car oui mine de rien il y a beaucoup de
                                chose a assimiler, j’ai déjà préparé une projet sous Symfony3 pour que vous
                                puissiez le faire de votre côté sans trop vous prendre la tete avec du
                                superflux.
                            </p>
                            <p>
                                Ah mince, j’ai oublié d’introduire mon plan …
                                On commencera par configurer notre projet Symfony pour que vous
                                puissiez tout de même le faire pour vos applications, puis configurer
                                Gitlab et Rancher et tester le tout. Bien entendu, si vous ne connaissez
                                pas Docker, Rancher et Gitlab, je m’y attarderais pas plus que ca.
                                Je vous laisse le soin d’apprendre de votre côté et revenir lire l’article.
                            </p>
                            <div class="row">
                                <div class="span4" style="text-align: center;">
                                    <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/diagramm-workflow.png') }}" target="_blank">
                                        <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/diagramm-workflow.png') }}" />
                                    </a>
                                    <i>Objectif</i>
                                </div>
                                <div class="span4" style="text-align: center;">
                                    <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/diagramm-activity.png') }}" target="_blank">
                                        <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/diagramm-activity.png') }}" />
                                    </a>
                                    <i>Diagramme d'activité</i>
                                </div>
                            </div>
                        </div>
                        <div class="span4">
                            <h2>Plan</h2>
                            <ul>
                                <li>
                                    <a href="#projet">Projet</a>
                                    <ul>
                                        <li><a href="#configuration-symfony">Configuration  de Symfony</a></li>
                                        <li><a href="#image-docker">Image Docker</a></li>
                                        <li><a href="#configuration-gitlabci">Configuration de GitlabCI</a></li>
                                        <li><a href="#gitlab-registry">Registry</a></li>
                                    </ul>
                                </li>
                                <li>
                                    <a href="#rancher">Rancher</a>
                                    <ul>
                                        <li><a href="#rancher-services">Services</a></li>
                                        <li><a href="#rancher-api">API</a></li>
                                    </ul>
                                </li>
                                <li>
                                    <a href="#gitlab">Gitlab</a>
                                    <ul>
                                        <li><a href="#gitlab-variables">Variables</a></li>
                                    </ul>
                                </li>
                                <li>
                                    <a href="#dernieres-modifications">Dernières modifications</a>
                                    <ul>
                                        <li><a href="#finalisation-gitlabci">Finalisation de la configuration de GitlabCI</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="span12">
                    <div class="row">
                        <div class="span12">
                            <h5>Note</h5>
                            <div class="span12">
                                Dans la suite de l’article, vous devrez changer certaine valeur
                                comme la valeur de la variable CONTAINER_TEST_IMAGE dans le fichier .gitlab-ci.yml
                                et l’image a monter dans Rancher.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="span12">
                    <div class="row">
                        <div class="span12">
                            <h2 id="projet">Projet</h2>
                            <h3 id="configuration-symfony">Configuration  de Symfony</h3>
                            <div class="row">
                                <div class="span12">
                                    <p>
                                        Comme annonce dans la presentation, vous pouvez directement utiliser
                                        l’exemple de projet que j’ai fait pour vous disponible en
                                        ligne : https://gitlab.com/anthonykgross/sample-continuous-deployment et
                                        passer directement la l’etape suivante.
                                        Dans le cas contraire, nous allons devoir configurer Symfony, créer
                                        l’image Docker contenant Nginx et PHP FPM avec son entrypoint et configurer le
                                        fichier .gitlab-ci.yml pour Gitlab.
                                    </p>
                                    <p>
                                        Sachant que nous allons faire les choses bien, c’est à dire lancer nos tests
                                        unitaires avant de déployer notre image nous allons tout d’abord installer PhpUnit.
                                    </p>
                                </div>
                                <div class="span4">
                                    <p>
                                        Via Composer, nous installons dans notre projet PhpUnit et ainsi
                                        nous pourrons lancer nos tests unitaires à l’avenir.
                                        Pour l’installer, voici la commande a executer a la racine de
                                        votre projet Symfony.
                                    </p>
                                    <pre class="language-bash"><code>
$ composer require phpunit/phpunit
                                    </code></pre>
                                </div>
                                <div class="span4">
                                    <p>
                                        Ensuite, nous allons définir nos constantes pour nos bases de données :
                                        une de prod et une de tests. Prêtez bien attention au noms des HOST
                                        (“prod-mysql” et “test-mysql”) : ils nous seront utiles à l’avenir.
                                    </p>
                                    <pre class="language-yaml"><code>
# app/config/parameters.yml.dist
database_host:     prod-mysql
database_port:     ~
database_name:     symfony
database_user:     root
database_password: symfony
test_database_host:     test-mysql
test_database_port:     ~
test_database_name:     database_test
test_database_user:     database_test
test_database_password: database_test
                                    </code></pre>
                                </div>
                                <div class="span4">
                                    <p>
                                        Pour finir, par défaut Symfony ne configure pas de base de
                                        données de tests donc nous allons lui demander, gentillement,
                                        d’en avoir une pour ne pas foutre le bordel dans notre
                                        base de données de prod.
                                    </p>
                                    <pre class="language-yaml"><code>
# app/config/config_test.yml
doctrine:
   dbal:
       driver:   pdo_mysql
       host:     "%test_database_host%"
       port:     "%test_database_port%"
       dbname:   "%test_database_name%"
       user:     "%test_database_user%"
       password: "%test_database_password%"
       charset:  UTF8
                                    </code></pre>
                                </div>
                                <div class="span12">
                                    <p>
                                        Jusqu’ici, c’est plutôt simple : Symfony utilisera nos constantes
                                        pour initialiser nos bases de données selon l’environnement
                                        souhaite et nous avons Phpunit dans notre projet pour lancer nos tests
                                        unitaire à venir.
                                    </p>
                                </div>
                            </div>
                            <h3 id="image-docker">Image Docker</h3>
                            <div class="row">
                                <div class="span12">
                                    <p>
                                        J’avais prévenu, je parlerais peu de Docker mais pour faire
                                        rapide on va avoir besoin de configurer notre serveur ainsi que
                                        son point d'entrée (l’entrypoint) qui donnera l’ordre à notre
                                        image d'exécuter un traitement désiré.
                                    </p>
                                </div>
                                <div class="span6">
                                    <p>
                                        Pour l’image, une configuration plutôt simple pour un serveur
                                        web basé sur Debian Jessie : PHP-FPM, Nginx, Composer
                                        (qui lui-même aura besoin de curl et git pour les dépendances)
                                        et Supervisor. Ce dernier s’occupera de lancer Nginx et PHP-FPM car
                                        Docker ne permet de lancer qu’un seul processus, or nous en avons
                                        besoin dans lancer deux. Supervisor sert a ca ! Bien entendu, nous
                                        balançons nos configurations pour Nginx et Supervisor dans notre
                                        image, notre entrypoint ainsi que les sources de notre projet Symfony et
                                        ouvrir les ports pour que notre site soit accessible depuis l’internet
                                        mondial !
                                    </p>
                                    <p>
                                        Je ne rentre pas dans les détails de la configuration du serveur,
                                        vous avez tout ce qu’il vous faut dans le projet d’exemple pour décortiquer
                                        avec exactitude comment fonctionne un serveur web.
                                    </p>
                                    <pre class="language-docker"><code>
# Dockerfile
FROM debian:jessie

MAINTAINER Anthony K GROSS<anthony.k.gross@gmail.com>

WORKDIR /src

RUN apt-get update -y && \
	apt-get upgrade -y && \
	apt-get install -y wget && \
	apt-get install -y php5-common php5-cli php5-fpm php5-mcrypt \
	                    php5-mysql php5-apcu php5-gd php5-imagick \
	                    php5-curl php5-intl php5-sqlite && \
	apt-get install -y curl git && \
	php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');" && \
    php composer-setup.php && \
    php -r "unlink('composer-setup.php');" && \
    chmod a+x composer.phar && \
    mv composer.phar /usr/local/bin/composer && \
    rm -rf /var/lib/apt/lists/* && \
    apt-get autoremove -y --purge

RUN apt-get update -y && \
	apt-get upgrade -y && \
	apt-get install -y supervisor nginx && \
    rm -rf /var/lib/apt/lists/* && \
    apt-get autoremove -y --purge && \
    usermod -u 1000 www-data

COPY entrypoint.sh /entrypoint.sh
COPY conf/supervisor /etc/supervisor/conf.d
COPY conf/nginx /etc/nginx
COPY src /src

RUN chmod 777 /src -Rf && \
    mkdir -p /logs && \
    chmod 777 /logs -Rf && \
    chmod +x /entrypoint.sh && \
    sh /entrypoint.sh install && \
    rm web/app_dev.php

EXPOSE 80
EXPOSE 443

ENTRYPOINT ["/entrypoint.sh"]
CMD ["run"]
                                </code></pre>
                                </div>
                                <div class="span6">
                                    <p>
                                        Le coeur de la tome : l’entrypoint. Plutôt simple lui aussi, explication :
                                        Il faut savoir que notre image Docker se lance par un point d'entrée qu’on
                                        peut redéfinir. Si vous regardez le Dockerfile a gauche, nous avons défini
                                        que notre entrypoint serait notre fichier entrypoint.sh, son contenu ci-dessous.
                                    </p>
                                    <p>
                                        Ici, nous voulons que selon le paramètre que nous enverrons à notre fichier
                                        soit à notre image Docker, vous suivez ?, qu’il “Install”, “tests” ou “run”
                                        notre serveur. Je recapitule : Si je fais “/entrypoint.sh install”:
                                        ca m’installe les dependences de Composer, “/entrypoint.sh tests”: ca me
                                        lances les tests unitaires et “/entrypoint.sh run” me lance Supervisor soit
                                        Nginx et PHP FPM. Je sens que je vais en perdre quelques-uns d’entre vous la …
                                    </p>
                                    <pre class="language-bash"><code>
# entrypoint.sh
#!/bin/bash
set -e

install() {
    composer install
    php bin/console assets:install
}

tests() {
    php vendor/bin/phpunit -c /src/
}

run() {
    supervisord
}

case "$1" in
"install")
    echo "Install"
    install
    ;;
"tests")
    echo "Tests"
    tests
    ;;
"run")
    echo "Run"
    run
    ;;
*)
    echo "Custom command : $@"
    exec "$@"
    ;;
esac
                            </code></pre>
                                </div>
                                <div class="span12">
                                    <p>
                                        Remarque : Avez vous remarque que je lance “/entrypoint.sh install”
                                        dans le Dockerfile ? Le but étant que lors de la construction de
                                        mon image, sachant qu’elle possède les sources de l’application,
                                        Docker m’installe les dépendances Composer. L'intérêt est que
                                        de cette manière, mon application est complete, prete a etre lancee.
                                    </p>
                                </div>
                            </div>
                            <h3 id="configuration-gitlabci">Configuration de GitlabCI</h3>
                            <p>
                                Pfiou, si vous êtes encore d’attaque on va faire la suite, le fichier
                                .gitlab-ci.yml. Ce fichier va permettre à notre application Gitlab de savoir
                                que nous voulons profiter de serveur d'intégration continue (GitlabCI),
                                c’est à dire, une machine qui lancera des traitements demandés à chaque
                                fois que nous lui envoyons des modifications de notre projet.
                            </p>
                            <p>
                                Le fichier décrit ci dessous demande à Gitlab que nous souhaitons,
                                pour ce projet seulement, un serveur d'intégration continue utilisant Docker
                                et que nous souhaitons utiliser du Docker dans cette machine Docker (DinD
                                signifie “Docker in Docker”).
                            </p>
                            <p>
                                GitlabCI fournit des variables par défaut comme $CI_BUILD_TOKEN,
                                $CI_REGISTRY et $CI_BUILD_REF_NAME. Cette dernière est le nom de la
                                branch git en cours, quand aux autres sont utiles pour éviter de définir
                                manuellement notre Registry, serveur de stockage d’image docker, et le
                                mot de passe pour se connecter à celui-ci.
                            </p>
                            <p>
                                Notre processus est divisé en deux tâches : Build (Construction) et Deploy
                                (Déploiement = mise en production). Nous nous occuperons que de la partie
                                Build ici.
                            </p>
                            <p>
                                Dans un premier temps, nous allons demander à GitlabCI de créer notre image
                                docker a partir du fichier Dockerfile  présent à la racine de notre projet.
                                Une fois que c’est fait, nous créons une base de données de test MySQL ainsi
                                que les identifiants de tests identiques à ceux de notre fichier de
                                paramètres Symfony. Ensuite on lie la base de donnees de données de test à
                                notre image Docker et on demande à Symfony de générer le schéma de la base
                                de données puis nous lançons les tests unitaires. Pour finir, si les tests
                                sont passés, nous nous connectons à notre Registry et poussons notre nouvelle
                                image fraîchement créée sur celui-ci.
                            </p>
                            <pre class="language-yaml"><code>
# .gitlab-ci.yml
image: docker:latest
services:
  - docker:dind

variables:
  CONTAINER_TEST_IMAGE: registry.gitlab.com/anthonykgross/sample-continuous-deployment:$CI_BUILD_REF_NAME

stages:
  - build
  - deploy

build:
  stage: build
  script:
    - docker build --file="Dockerfile" --tag="$CONTAINER_TEST_IMAGE" .
    - docker run --name gitlab-mysql -e MYSQL_DATABASE=database_test -e MYSQL_USER=database_test -e MYSQL_PASSWORD=database_test -e MYSQL_ROOT_PASSWORD=root -d mysql:5.5.44
    - docker run --link gitlab-mysql:test-mysql $CONTAINER_TEST_IMAGE php bin/console doctrine:schema:update --force --env=test
    - docker run --link gitlab-mysql:test-mysql $CONTAINER_TEST_IMAGE tests
    - docker login -u "gitlab-ci-token" -p "$CI_BUILD_TOKEN" $CI_REGISTRY
    - docker push $CONTAINER_TEST_IMAGE

deploy:
  stage: deploy
  image: cdrx/rancher-gitlab-deploy
  only:
    - master
  script:
    - echo "Deployment not configured"
                            </code></pre>
                            <h3 id="gitlab-registry">Registry</h3>
                            <div class="row">
                                <div class="span8">
                                    Du coup, rendez vous dans votre projet sur votre Gitlab et allez dans
                                    Pipeline. Si tout s’est bien passé, vous verrez que celui-ci s’est
                                    déroulé avec succès et vous retrouvez votre image prête à l’utilisation
                                    dans Registry. Dans le cas contraire, j’ai pas ete assez claire et vous
                                    avez manqué un truc, ou vos tests unitaire sont faux. Dans les deux
                                    cas … débrouillez vous ! <3 Ou bien, préciser votre problème en
                                    commentaire que je puisse affiner la qualité de mon article.

                                    <div style="text-align: center;">
                                        <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/gitlab-pipeline.png') }}" target="_blank">
                                            <img style="width: 75%;" src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/gitlab-pipeline.png') }}" />
                                        </a>
                                        <br/>
                                        <i>Le build s'est bien passé</i>
                                    </div>
                                </div>
                                <div class="span4" style="text-align: center;">
                                    <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/gitlab-registry.png') }}" target="_blank">
                                        <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/gitlab-registry.png') }}" />
                                    </a>
                                    <i>Notre image Docker dans le registry</i>
                                </div>
                            </div>

                            <h2 id="rancher">Rancher</h2>
                            <h3 id="rancher-services">Services</h3>
                            <div class="row">
                                <div class="span4" style="text-align: center;">
                                    <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/rancher-mysql.png') }}" target="_blank">
                                        <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/rancher-mysql.png') }}" />
                                    </a>
                                    <i>MySQL</i>
                                    <hr>
                                    <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/rancher-symfony.png') }}" target="_blank">
                                        <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/rancher-symfony.png') }}" />
                                    </a>
                                    <i>Symfony3</i>
                                </div>
                                <div class="span8">
                                    <p>
                                        Si vous le ne le connaissez pas encore, Rancher est le programme qui
                                        va gérer nos containers en productions. Si vous ne savez pas l’installer,
                                        vous avez la procédure d’installation en Liens Utiles. Admettons qu’il reste
                                        des survivants qui liront la suite de cet article, nous allons préparer notre
                                        machine de production. Tout d’abord, nous allons créer notre base de données
                                        de prod, configurer le container de notre projet et générer les identifiants
                                        de l’API Rancher pour la partie finale du post.
                                    </p>
                                    <p>
                                        Connectez vous sur votre serveur Rancher, puis allez Infrastructure > Registries
                                        et Add Registry.
                                        Ici, nous allons ajouter notre registry Gitlab pour que notre Rancher
                                        puisse avoir accès à nos image Docker.
                                    </p>
                                    <p>
                                        Address : registry.gitlab.com
                                        Email : Sérieusement, vous vous débrouillerez je pense :)
                                        Username : Votre login Gitlab
                                        Password : Votre mot de passe Gitlab
                                    </p>
                                    <p>
                                        Ensuite, allez dans Environment > Default et Add Service. Comme dans la
                                        premiere capture, nous allons installer MySQL. La configuration a suivre :
                                    </p>
                                    <p>
                                        Name : mysql
                                        Image : mysql-5.5.44
                                        Port : 3306 > 3306
                                    </p>
                                    <p>
                                        Si vous connaissez Docker, vous savez à quoi correspond ces champs. Si ce
                                        n’est pas le cas, je vous incite à revoir votre copie.
                                    </p>
                                    <p>
                                        Une fois le container démarre, cliquez sur l’instance et dans l’onglet
                                        Container vous retrouverez l'état de la machine. Dans le Menu, recherchez
                                        Execute Shell : vous êtes loggé dans votre container. Créer les identifiants
                                        MySQL pour votre base de données de prod; vous vous rappelez ? Dans le
                                        fichier parameters.yml.dist de notre projet symfony. Les memes oui !
                                    </p>
                                    <p>
                                        La suite sera de creer un second container
                                    </p>
                                    <p>
                                        Name : symfony3_app
                                        Image : registry.gitlab.com/anthonykgross/sample-continuous-deployment:master
                                        Port 80 > 80
                                        Liens : Mysql > prod-mysql
                                    </p>
                                    <p>
                                        Rancher telechargera l’image de votre Registry, créera le container a partir
                                        de votre image et fera le liens entre l’instance MySQL nommé “mysql” vers le
                                        container de notre projet sous le nom de “prod-mysql” (parameters.yml.dist)
                                    </p>
                                </div>
                            </div>
                            <h3 id="rancher-api">API</h3>
                            <div class="row">
                                <div class="span12" style="text-align: center;">
                                    <p>
                                        On arrive au bout les copains ! Sous Rancher, cliquez sur API et
                                        générez une Access Key et une Secret Key. Aucun pré requis
                                        nécessaires à renseigner mais conserver vos identifiants, on va
                                        s’en servir de suite.
                                    </p>
                                </div>
                            </div>
                            <h2 id="gitlab">Gitlab</h2>
                            <div class="row">
                                <div class="span12" style="text-align: center;">
                                    <p>
                                        Dans votre projet sous Gitlab, trouvez la section Variables. Nous allons
                                        définir des constantes pour pouvoir les utiliser dans ton fichier
                                        .gitlab-ci.yml. Pourquoi définir des variables au lieu d'écrire
                                        directement nos valeurs dans le fichier en question ? Tout simplement car
                                        si vous avez à travailler avec plusieurs personnes sur le projet, vous n'êtes
                                        pas obligé de rendre public les accès au serveur de production. Dans le fichier
                                        .gitlab-ci.yml, tous vos collaborateurs pourraient avoir accès à vos clés
                                        alors qu’en tant que variables Gitlab, seulement le serveur d'intégration
                                        continue, GitlabCI.
                                    </p>
                                </div>
                            </div>

                            <h3 id="gitlab-variables">Variables</h3>
                            <div class="row">
                                <div class="span12">
                                    <p>
                                        Définissez les variables comme ci-dessous :
                                    </p>
                                </div>
                                <div class="span6" style="text-align: center;">
                                    <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/gitlab-variables.png') }}" target="_blank">
                                        <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/gitlab-variables.png') }}" />
                                    </a>
                                    <i>Ajout des variables dans Gitlab</i>
                                </div>
                                <div class="span6">
                                    <pre class="language-bash"><code>
RANCHER_ACCESS_KEY  MY_RANCHER_ACCESS_KEY
RANCHER_ENV Default
RANCHER_SECRET_KEY  MY_RANCHER_SECRET_KEY
RANCHER_SERVICE symfony3_app
RANCHER_STACK   Default
RANCHER_URL http://yourdomain.com:8080
                                    </code></pre>
                                </div>
                                <div class="span12">
                                    <p>
                                        Je pense pour ce qui est de  RANCHER_ACCESS_KEY et  RANCHER_SECRET_KEY c’est evident :
                                        Elles serviront à se connecter à L’API de Rancher. La variable RANCHER_URL est l’adresse
                                        et le port d'accès au votre serveur Rancher. Pour ce qui est de RANCHER_ENV et RANCHER_STACK
                                        sont vraiment spécifiques à notre gestionnaire de containers et votre configuration. Rappelez vous,
                                        après l’ajout de notre Registry, nous avons ajouté notre machine Mysql dans l’environnement Default.
                                        Sachez que si vous utilisez Rancher avec la configuration par défaut, laissez ces valeurs “Default”
                                        pour ces deux variables. Sinon, a vous de savoir comment remplir ces champs. Enfin, RANCHER_SERVICE
                                        c’est le nom de la machine que vous voudrez mettre à jour après chacune des mise a jour de nos
                                        sources du projet; ici “symfony3_app” créé juste avant la génération des identifiants API.
                                    </p>
                                </div>
                            </div>

                            <h2 id="dernieres-modifications">Dernières modifications</h2>
                            <h3 id="finalisation-gitlabci">Finalisation de la configuration de GitlabCI</h3>
                            <div class="row">
                                <div class="span12">
                                    <p>
                                        Ca y est, on est a la fin ! Nous n’avons plus qu’a éditer notre fichier
                                        .gitlab-ci.yml et ajouter dans l'étape “deploy”, la command de mise à
                                        jour de notre image docker de notre projet par celle que nous venons
                                        juste de créer. Une fois terminée, tout se derouler comme sur des
                                        roulettes.
                                    </p>
                                    <pre class="language-yaml"><code>
# .gitlab-ci.yml
...
deploy:
  stage: deploy
  image: cdrx/rancher-gitlab-deploy
  only:
    - master
  script:
    - upgrade --environment $RANCHER_ENV --stack $RANCHER_STACK --service $RANCHER_SERVICE --no-start-before-stopping --no-wait-for-upgrade-to-finish
                                    </code></pre>
                                    <p>
                                        Pour vérifier, ouvrez votre serveur Rancher et allez dans la liste
                                        des service en cours. Ouvrez dans une autre fenêtre votre Gitlab.
                                        Modifiez les sources de votre projet ou celui-ci que je vous ai
                                        fourni et poussez les modifications sur la branche Master.
                                        Gitlab recevra votre commit, lancera vos tests unitaires et signalera
                                        a Rancher que celui-ci doit mettre à jour le service dont le nom est
                                        “Symfony3_app”. Regardez sur Rancher, votre service est en cours de
                                        mise à jour, redémarre et votre nouvelle image est en production.
                                        Bien entendu, si vous avez correctement configuré votre image docker,
                                        vos nom de domaines, etc … (Tout ce qui vous est propre), vous devriez
                                        voir la nouvelle version de votre site à votre adresse.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <br/>
            <div class="row">
                <div class="span12">
                    <div class="row">
                        <div class="span12">
                            <h2>Conclusion</h2>
                            <p>
                               Sur ce, j'ai garé ma baleine en double file. Tchou !
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            <br/>
            <div class="row">
                <div class="span12">
                    <div class="row">
                        <div class="span12">
                            <h3>Liens utiles</h3>
                            <li><a href="https://gitlab.com/anthonykgross/sample-continuous-deployment" target="_blank">Projet Symfony d'exemple</a></li>
                            <li><a href="https://docs.gitlab.com/ce/ci/docker/using_docker_build.html" target="_blank">En avoir plus sur GitlabCI avec Docker</a></li>
                            <li><a href="https://docs.rancher.com/rancher/v1.2/en/installing-rancher/installing-server/" target="_blank">Installation de Rancher</a></li>
                        </div>
                    </div>
                </div>
            </div>
            <br/>
            <div class="meta-desc">
                <i class="fa fa-calendar"></i> &nbsp; Le 14 Novembre 2016 <span class="font-slight"></span>
            </div>
            <br/>
            <div class="fb-comments" data-href="{{ block("og_url") }}" data-numposts="5" data-width="100%"></div>
        </section> <!-- End blog -->
    </div> <!-- End container -->
{% endblock %}