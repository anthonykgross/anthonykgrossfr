{% extends 'base.html.twig' %}

{% block title %}Déploiement continu avec Docker entre Gitlab et Rancher{% endblock %}
{% block description %}L'utilisation d'un gestionnaire de containers ainsi que l'élaboration de procédures de déploiement.{% endblock %}
{% block og_url %}http://{{ app.request.host ~ path('anthonykgrossfr_page_lire', {'name' : 'deploiement-continu-docker-gitlab-rancher' }) }}{% endblock %}
{% block og_image %}http://{{ app.request.host ~  asset("bundles/anthonykgrossfrmain/images/Articles/deploiement-continu-docker-gitlab-rancher.jpg") }}{% endblock %}

{% block javascripts %}
<script type="application/ld+json" xmlns="http://www.w3.org/1999/html">
    {
        "@context": "http://schema.org",
        "@type": "NewsArticle",
        "mainEntityOfPage":{
            "@type":"WebPage",
            "@id":"{{ block("og_url") }}"
        },
        "headline": "{{ block("title") }}",
        "image": {
            "@type": "ImageObject",
            "url": "{{ block("og_image") }}",
            "height": 400,
            "width": 1200
        },
        "datePublished": "{{ "2016-11-14"|date("c") }}",
        "dateModified": "{{ "2016-11-14"|date("c") }}",
        "author": {
            "@type": "Person",
            "name": "Anthony GROSS"
        },
        "publisher": {
            "@type": "Organization",
            "name": "AnthonyKGROSS",
            "logo": {
                "@type": "ImageObject",
                "url": "http://anthonykgross.fr/images/akg-wide.png",
                "width": 80,
                "height": 60
            }
        },
        "description": "{{ block("description") }}"
    }
</script>
{% endblock %}

{% block body %}
    <div class="container">
        <section id="blog" class="single-page">
            <div class="header margin-bottom40">
                <h2>Déploiement continu avec Docker entre Gitlab et Rancher</h2>
                <p>
                    Avec la progression de l’utilisation des containers d’application (Docker, AWS, etc …) favorisant
                    les architectures microservices, nous divisons nos programmes en un ensemble de petits programmes
                    communiquant les uns avec les autres. Cette division engendre une multiplication croissante du
                    nombre de machines qui, avec le temps, deviennent de plus en plus difficiles à gérer.
                    Par conséquent, il est nécessaire d'utiliser un gestionnaire de containers ainsi que
                    l'élaboration de procédures de déploiement. Et comme par hasard, mon article parle de ça !
                </p>
            </div>
            <div class="item">
                <figure>
                    <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/deploiement-continu-docker-gitlab-rancher.jpg') }}" alt="Thumbnail" />
                </figure>
            </div>
            <br/>
            <div class="row">
                <div class="span12">
                    <div class="row">
                        <div class="span8">
                            <h2>Présentation</h2>
                            <p>
                                La procédure que je vous propose est plutôt simple : à partir d'un simple commit sur notre
                                serveur Git fourni par Gitlab, nous allons construire notre machine,
                                lancer nos tests (Oui, car c'est important!) et si tout se passe bien : on balance le
                                tout en prod’.
                                Pour faciliter la compréhension, car il y a beaucoup de
                                choses à assimiler, j’ai préparé pour vous un projet sous Symfony3 pour que vous
                                puissiez le faire de votre côté sans trop vous prendre la tête avec le
                                superflu.
                            </p>
                            <p>
                                Ah mince, j’ai oublié d’introduire mon plan …
                                On commencera par configurer notre projet Symfony, puis par configurer
                                Gitlab et Rancher. Bien entendu, si vous ne connaissez
                                pas Docker, Rancher et Gitlab, je vous laisse le soin d’apprendre ces prérequis de votre
                                côté et revenir lire l’article. Pour les plus motivés, deux petits diagrammes pour avoir une vue
                                d'ensemble de ce qu'on s'apprête à faire.
                            </p>
                            <div class="row">
                                <div class="span4" style="text-align: center;">
                                    <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/diagramm-workflow.png') }}" target="_blank">
                                        <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/diagramm-workflow.png') }}" />
                                    </a>
                                    <i>Objectif</i>
                                </div>
                                <div class="span4" style="text-align: center;">
                                    <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/diagramm-activity.png') }}" target="_blank">
                                        <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/diagramm-activity.png') }}" />
                                    </a>
                                    <i>Diagramme d'activité</i>
                                </div>
                            </div>
                        </div>
                        <div class="span4">
                            <h2>Plan</h2>
                            <ul>
                                <li>
                                    <a class="active-anchor" href="#projet">Projet</a>
                                    <ul>
                                        <li><a class="active-anchor" href="#configuration-symfony">Configuration  de Symfony</a></li>
                                        <li><a class="active-anchor" href="#image-docker">Image Docker</a></li>
                                        <li><a class="active-anchor" href="#configuration-gitlabci">Configuration de GitlabCI</a></li>
                                        <li><a class="active-anchor" href="#gitlab-registry">Registry</a></li>
                                    </ul>
                                </li>
                                <li>
                                    <a class="active-anchor" href="#rancher">Rancher</a>
                                    <ul>
                                        <li><a class="active-anchor" href="#rancher-services">Services</a></li>
                                        <li><a class="active-anchor" href="#rancher-api">API</a></li>
                                    </ul>
                                </li>
                                <li>
                                    <a class="active-anchor" href="#gitlab">Gitlab</a>
                                    <ul>
                                        <li><a class="active-anchor" href="#gitlab-variables">Variables</a></li>
                                    </ul>
                                </li>
                                <li>
                                    <a class="active-anchor" href="#dernieres-modifications">Dernières modifications</a>
                                    <ul>
                                        <li><a class="active-anchor" href="#finalisation-gitlabci">Finalisation de la configuration de GitlabCI</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="span12">
                    <div class="row">
                        <div class="span12">
                            <h5>Note</h5>
                            <div class="span12">
                                Dans la suite de l’article, vous devrez changer par vos propres valeurs la variable
                                <b>CONTAINER_TEST_IMAGE</b> dans le fichier <a class="active-anchor" href="#configuration-gitlabci">.gitlab-ci.yml</a>
                                et <a class="active-anchor" href="#rancher-image-symfony">l’image  à monter de votre projet Symfony</a> dans l'interface Rancher.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="span12">
                    <div class="row">
                        <div class="span12">
                            <br/>
                            <h2 id="projet">Projet</h2>
                            <br/>
                            <h3 id="configuration-symfony">Configuration  de Symfony</h3>
                            <div class="row">
                                <div class="span12">
                                    <p>
                                        Comme annoncé dans la présentation, vous pouvez directement utiliser
                                        <a href="https://gitlab.com/anthonykgross/sample-continuous-deployment" target="_blank">
                                            le projet d'exemple disponible en ligne
                                        </a> qui vous permettra de suivre plus facilement l'article.
                                        Nous allons devoir configurer Symfony, créer
                                        l’image Docker contenant Nginx et PHP FPM avec son entrypoint et configurer le
                                        fichier .gitlab-ci.yml pour Gitlab.
                                    </p>
                                    <p>
                                        Sachant que nous allons bien faire les choses, c’est à dire lancer nos tests
                                        unitaires avant de déployer notre image, nous allons tout d’abord installer PhpUnit.
                                        Bien entendu, si vous ne souhaitez pas lancer les tests, c'est à vous que revient
                                        d'adapter la suite du post.
                                    </p>
                                </div>
                                <div class="span4">
                                    <p>
                                        Via Composer, nous installons PhpUnit et ainsi
                                        nous pourrons lancer nos tests unitaires à l’avenir.
                                        Pour l’installer, voici la commande à exécuter à la racine de
                                        votre projet Symfony.
                                    </p>
                                    <pre class="language-bash"><code>
$ composer require phpunit/phpunit
                                    </code></pre>
                                </div>
                                <div class="span4">
                                    <p>
                                        Ensuite, nous définissons nos constantes pour nos bases de données :
                                        une pour la prod et une pour les tests. Prêtez bien attention aux noms des HOST
                                        (“<b>prod-mysql</b>” et “<b>test-mysql</b>”) : ils nous seront utiles bientôt.
                                    </p>
                                    <pre class="language-yaml"><code>
# app/config/parameters.yml.dist
database_host:     prod-mysql
database_port:     ~
database_name:     symfony
database_user:     root
database_password: symfony
test_database_host:     test-mysql
test_database_port:     ~
test_database_name:     database_test
test_database_user:     database_test
test_database_password: database_test
                                    </code></pre>
                                </div>
                                <div class="span4">
                                    <p>
                                        Pour finir, nous demandons gentiment à Symfony de configurer notre base de
                                        données de tests (Oui car nous ne souhaitons pas foutre le bordel dans notre
                                        base de données de prod).
                                    </p>
                                    <pre class="language-yaml"><code>
# app/config/config_test.yml
doctrine:
   dbal:
       driver:   pdo_mysql
       host:     "%test_database_host%"
       port:     "%test_database_port%"
       dbname:   "%test_database_name%"
       user:     "%test_database_user%"
       password: "%test_database_password%"
       charset:  UTF8
                                    </code></pre>
                                </div>
                                <div class="span12">
                                    <p>
                                        Jusqu’ici, c’est plutôt simple : Symfony utilisera nos constantes
                                        pour initialiser nos bases de données selon l’environnement
                                        souhaité et nous avons Phpunit dans notre projet pour lancer nos tests
                                        unitaires.
                                    </p>
                                </div>
                            </div>
                            <br/>
                            <h3 id="image-docker">Image Docker</h3>
                            <div class="row">
                                <div class="span12">
                                    <p>
                                        J’avais prévenu : je parlerais peu de Docker. Pour faire
                                        rapide, on va avoir besoin de configurer notre serveur ainsi que
                                        son point d'entrée (l’<b>entrypoint</b>) qui donnera l’ordre à notre
                                        image d'exécuter un traitement désiré.
                                    </p>
                                </div>
                                <div class="span6">
                                    <p>
                                        Pour l’image, une configuration plutôt simple pour un serveur
                                        web basé sur Debian Jessie : PHP-FPM, Nginx, Composer
                                        (qui lui-même aura besoin de curl et git pour les dépendances)
                                        et Supervisor. Ce dernier s’occupera de lancer Nginx et PHP-FPM car
                                        Docker ne permet de lancer qu’un seul processus. Or, nous avons
                                        besoin d'en lancer deux. Supervisor sert à ça ! Bien entendu, nous
                                        balançons dans notre image nos configurations pour Nginx et Supervisor,
                                        notre entrypoint ainsi que les sources de notre projet Symfony. Ne pas oublier
                                        d'ouvrir les ports pour que notre site soit accessible depuis l’internet
                                        mondial !
                                    </p>
                                    <p>
                                        Je n'entre pas dans les détails de la configuration du serveur,
                                        vous avez tout ce qu’il vous faut dans le projet d’exemple pour décortiquer
                                        avec exactitude comment ça fonctionne.
                                    </p>
                                    <pre class="language-docker"><code>
# Dockerfile
FROM debian:jessie

MAINTAINER Anthony K GROSS<anthony.k.gross@gmail.com>

WORKDIR /src

RUN apt-get update -y && \
	apt-get upgrade -y && \
	apt-get install -y wget && \
	apt-get install -y php5-common php5-cli php5-fpm php5-mcrypt \
	                    php5-mysql php5-apcu php5-gd php5-imagick \
	                    php5-curl php5-intl php5-sqlite && \
	apt-get install -y curl git && \
	php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');" && \
    php composer-setup.php && \
    php -r "unlink('composer-setup.php');" && \
    chmod a+x composer.phar && \
    mv composer.phar /usr/local/bin/composer && \
    rm -rf /var/lib/apt/lists/* && \
    apt-get autoremove -y --purge

RUN apt-get update -y && \
	apt-get upgrade -y && \
	apt-get install -y supervisor nginx && \
    rm -rf /var/lib/apt/lists/* && \
    apt-get autoremove -y --purge && \
    usermod -u 1000 www-data

COPY entrypoint.sh /entrypoint.sh
COPY conf/supervisor /etc/supervisor/conf.d
COPY conf/nginx /etc/nginx
COPY src /src

RUN chmod 777 /src -Rf && \
    mkdir -p /logs && \
    chmod 777 /logs -Rf && \
    chmod +x /entrypoint.sh && \
    sh /entrypoint.sh install && \
    rm web/app_dev.php

EXPOSE 80
EXPOSE 443

ENTRYPOINT ["/entrypoint.sh"]
CMD ["run"]
                                </code></pre>
                                </div>
                                <div class="span6">
                                    <p>
                                        Le coeur de la tomme : l’<b>entrypoint</b>. Il faut savoir que notre image Docker
                                        se lance par un point d'entrée qu’on peut redéfinir. Si vous regardez
                                        le Dockerfile à gauche, nous avons défini
                                        que ce point d'entrée serait notre fichier entrypoint.sh.
                                    </p>
                                    <p>
                                        Nous souhaitons que, selon le paramètre que nous envoyons à notre fichier entrypoint.sh,
                                        l'image exécute une fonction particulière. Vous suivez ? Autrement dit, qu’il "install”, “tests” ou “run”
                                        notre serveur. Je recapitule : si je fais “/entrypoint.sh install”:
                                        ça m’installe les dépendances de Composer, “/entrypoint.sh tests”: ça me
                                        lance les tests unitaires et “/entrypoint.sh run” me lance Supervisor, c'est à dire
                                        Nginx et PHP FPM. Je sens que je vais en perdre quelques-uns d’entre vous là …
                                    </p>
                                    <pre class="language-bash"><code>
# entrypoint.sh
#!/bin/bash
set -e

install() {
    composer install
    php bin/console assets:install
}

tests() {
    php vendor/bin/phpunit -c /src/
}

run() {
    supervisord
}

case "$1" in
"install")
    echo "Install"
    install
    ;;
"tests")
    echo "Tests"
    tests
    ;;
"run")
    echo "Run"
    run
    ;;
*)
    echo "Custom command : $@"
    exec "$@"
    ;;
esac
                            </code></pre>
                                </div>
                                <div class="span12">
                                    <p>
                                        Remarque : avez-vous remarqué que je lance “/entrypoint.sh install”
                                        dans le Dockerfile ? Le but étant que lors de la construction de
                                        notre image, sachant qu’elle possède les sources de l’application,
                                        Docker m’installe les dépendances de Composer directement. L'intérêt est que
                                        de cette manière, mon application est complète, prête à être lancée, avec tous ses prérequis.
                                    </p>
                                </div>
                            </div>
                            <br/>
                            <h3 id="configuration-gitlabci">Configuration de GitlabCI</h3>
                            <p>
                                Pfiou, si vous êtes encore d’attaque on va faire la suite : le fichier
                                <b>.gitlab-ci.yml</b>. Ce fichier va permettre à notre Gitlab de savoir
                                que nous voulons profiter de son serveur d'intégration continue (GitlabCI),
                                c’est à dire, une machine qui lancera les traitements demandés à chaque
                                fois que nous lui envoyions des modifications de notre projet.
                            </p>
                            <p>
                                Le fichier décrit ci-dessous demande à Gitlab que nous souhaitons,
                                pour ce repository seulement, un serveur d'intégration continue utilisant Docker
                                et que nous souhaitons utiliser du Docker dans cette machine (DinD
                                signifie “<b>Docker in Docker</b>”).
                            </p>
                            <p>
                                GitlabCI fournit des variables par défaut comme <b>$CI_BUILD_TOKEN</b>,
                                <b>$CI_REGISTRY</b> et <b>$CI_BUILD_REF_NAME</b>. Cette dernière est le nom de la
                                branche git en cours. Quant aux autres, elles sont utiles pour éviter de définir
                                manuellement notre serveur de stockage d’images Docker (<b>Registry</b>) et le
                                mot de passe pour s'y connecter.
                            </p>
                            <p>
                                Notre procédure de déploiement est divisée en deux tâches : <b>Build</b> (Construction) et <b>Deploy</b>
                                (Déploiement = mise en production). Nous nous occuperons que de la partie
                                Build pour le moment.
                            </p>
                            <p>
                                Dans un premier temps, nous demandons à <b>GitlabCI</b> de créer notre image
                                Docker à partir du fichier Dockerfile présent à la racine de notre projet.
                                Une fois générée, nous créons une base de données MySQL de test ainsi
                                que les identifiants de tests identiques à ceux de <a class="active-anchor" href="#configuration-symfony">notre fichier de
                                paramètres Symfony</a>. Ensuite, on lie la base de données de test à
                                notre image précédemment construite et nous demandons à Symfony de générer le schéma de la base
                                de données. Vient le tour de lancer les tests unitaires. Pour finir, si les tests
                                sont passés avec succès, nous nous connectons à notre Registry et poussons notre nouvelle
                                image fraîchement créée sur celui-ci.
                            </p>
                            <pre class="language-yaml"><code>
# .gitlab-ci.yml
image: docker:latest
services:
  - docker:dind

variables:
  # Ici vous mettez VOTRE image, pas la mienne :) !
  CONTAINER_TEST_IMAGE: registry.gitlab.com/anthonykgross/sample-continuous-deployment:$CI_BUILD_REF_NAME

stages:
  - build
  - deploy

build:
  stage: build
  script:
    - docker build --file="Dockerfile" --tag="$CONTAINER_TEST_IMAGE" .
    - docker run --name gitlab-mysql -e MYSQL_DATABASE=database_test -e MYSQL_USER=database_test -e MYSQL_PASSWORD=database_test -e MYSQL_ROOT_PASSWORD=root -d mysql:5.5.44
    - docker run --link gitlab-mysql:test-mysql $CONTAINER_TEST_IMAGE php bin/console doctrine:schema:update --force --env=test
    - docker run --link gitlab-mysql:test-mysql $CONTAINER_TEST_IMAGE tests
    - docker login -u "gitlab-ci-token" -p "$CI_BUILD_TOKEN" $CI_REGISTRY
    - docker push $CONTAINER_TEST_IMAGE

deploy:
  stage: deploy
  image: cdrx/rancher-gitlab-deploy
  only:
    - master
  script:
    - echo "Deployment not configured"
                            </code></pre>
                            <p>
                                Une fois terminées, vous pouvez envoyer vos modifications sur Gitlab via Git. Si vous avez été
                                un élève assidu, le service GitlabCI a dû se déclencher et l'image Docker est en cours de construction.
                            </p>
                            <br/>
                            <h3 id="gitlab-registry">Registry</h3>
                            <div class="row">
                                <div class="span8">
                                    Du coup, rendez vous dans votre projet sur votre Gitlab et allez dans
                                    <b>Pipeline</b>. Si tout s’est bien passé, vous verrez que celui-ci s’est
                                    déroulé avec succès et vous retrouvez votre image prête à l’utilisation
                                    dans Registry. Dans le cas contraire, je n’ai pas dû être assez clair et vous
                                    avez manqué un truc, ou vos tests unitaires sont faux. Dans les deux
                                    cas … débrouillez vous ! <3 Ou bien, précisez votre problème en
                                    commentaire que je puisse affiner la qualité de mon article.
                                    <br/><br/>
                                    <div style="text-align: center;">
                                        <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/gitlab-pipeline.png') }}" target="_blank">
                                            <img style="width: 75%;" src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/gitlab-pipeline.png') }}" />
                                        </a>
                                        <br/>
                                        <i>Le build s'est bien passé</i>
                                    </div>
                                </div>
                                <div class="span4" style="text-align: center;">
                                    <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/gitlab-registry.png') }}" target="_blank">
                                        <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/gitlab-registry.png') }}" />
                                    </a>
                                    <i>Notre image Docker dans le registry</i>
                                </div>
                            </div>
                            <br/>
                            <h2 id="rancher">Rancher</h2>
                            <br/>
                            <h3 id="rancher-services">Services</h3>
                            <div class="row">
                                <div class="span4" style="text-align: center;">
                                    <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/rancher-mysql.png') }}" target="_blank">
                                        <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/rancher-mysql.png') }}" />
                                    </a>
                                    <i>MySQL</i>
                                    <hr>
                                    <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/rancher-details-mysql.png') }}" target="_blank">
                                        <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/rancher-details-mysql.png') }}" />
                                    </a>
                                    <i>Détails du container MySQL</i>
                                    <hr>
                                    <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/rancher-symfony.png') }}" target="_blank">
                                        <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/rancher-symfony.png') }}" />
                                    </a>
                                    <i>Symfony3</i>
                                </div>
                                <div class="span8">
                                    <p>
                                        Si vous ne le connaissez pas encore, <b>Rancher</b> est le programme qui
                                        va gérer nos containers en production. Si vous ne savez pas l’installer,
                                        vous avez la procédure d’installation en <a class="active-anchor" href="#liens-utiles">Liens Utiles</a>. Admettons qu’il reste
                                        des survivants qui liront la suite de cet article, nous allons paramétrer notre
                                        machine. Tout d’abord, nous allons créer notre base de données
                                        de prod, configurer le container de notre projet et générer les identifiants
                                        de l’API Rancher pour la partie finale du post.
                                    </p>
                                    <p>
                                        Connectez vous sur votre serveur <b>Rancher</b> (http://yourdomain.com:8080 pour l'exemple),
                                        puis allez dans <b>Infrastructure</b> > <b>Registries</b> et <b>Add Registry</b>.
                                        Ici, nous ajoutons notre registry Gitlab pour que Rancher
                                        puisse avoir accès à nos images Docker.
                                    </p>
                                    <p>
                                    <pre class="language-yaml"><code>
Address : registry.gitlab.com # Ou l'adresse de votre registry
Email : Sérieusement ? débrouillerez vous ! :)
Username : Votre login Gitlab
Password : Votre mot de passe Gitlab
                                    </code></pre>
                                    </p>
                                    <p>
                                        Ensuite, allez dans <b>Environment</b> > <b>Default</b> et <b>Add Service</b>. Comme dans la
                                        première capture, nous allons installer MySQL. La configuration à suivre :
                                    </p>
                                    <pre class="language-yaml"><code>
Name : mysql
Image : mysql-5.5.44
Port : 3306 > 3306
                                    </code></pre>
                                    <p>
                                        Si vous connaissez Docker, vous savez à quoi correspondent ces champs. Si ce
                                        n’est pas le cas, je vous incite à revoir votre copie.
                                    </p>
                                    <p>
                                        Une fois le container démarré, cliquez sur l’instance et dans l’onglet
                                        <b>Container</b> vous retrouvez l'état de la machine. Dans le <b>Menu</b>, recherchez
                                        <b>Execute Shell</b> : vous êtes désormais loggé dans votre container. Créez les identifiants
                                        MySQL pour votre base de données de prod; vous vous rappelez ? Dans le
                                        fichier <a class="active-anchor" href="#configuration-symfony">parameters.yml.dist</a> de notre projet Symfony.
                                        Les mêmes oui ! <b>Note</b> : n'oubliez pas de mettre l'accès à votre base de données depuis l'extérieur à votre utilisateur ! ("<b>%</b>" au lieu de "<b>localhost</b>")
                                    </p>
                                    <p>
                                        La suite sera de créer un second container, celui de notre application Symfony.
                                    </p>
                                    <p id="rancher-image-symfony">
                                        <pre class="language-yaml"><code>
Name : symfony3_app
# Ici vous mettez VOTRE image, pas la mienne :) !
Image : registry.gitlab.com/anthonykgross/sample-continuous-deployment:master
Port : 80 > 80
Liens : Mysql > prod-mysql
                                        </code></pre>
                                    </p>
                                    <p>
                                        Rancher téléchargera l’image de votre <b>Registry</b>, créera le container à partir
                                        de votre image et liera l’instance MySQL nommé “<b>mysql</b>” au
                                        container de notre projet sous le nom de “<b>prod-mysql</b>” (<a class="active-anchor" href="#configuration-symfony">parameters.yml.dist</a>).
                                    </p>
                                </div>
                            </div>
                            <br/>
                            <h3 id="rancher-api">API</h3>
                            <div class="row">
                                <div class="span12" style="text-align: center;">
                                    <p>
                                        On arrive au bout les copains ! Sous <b>Rancher</b>, cliquez sur <b>API</b> et
                                        générez une <b>Access Key</b> et une <b>Secret Key</b>. Aucun prérequis à renseigner
                                        mais conservez vos identifiants, on va s’en servir tout de suite.
                                    </p>
                                </div>
                            </div>
                            <br/>
                            <h2 id="gitlab">Gitlab</h2>
                            <div class="row">
                                <div class="span12" style="text-align: center;">
                                    <p>
                                        Dans votre projet sous <b>Gitlab</b>, trouvez la section <b>Variables</b>. Nous allons
                                        définir des constantes pour pouvoir les utiliser dans le fichier
                                        <b>.gitlab-ci.yml</b>. Pourquoi définir des variables au lieu d'écrire
                                        directement nos valeurs dans le fichier en question ? Tout simplement car
                                        si vous devez travailler avec plusieurs personnes sur le projet, vous ne serez
                                        pas contraints de rendre public les accès au serveur de production. S'ils sont écrits en clair
                                        dans le fichier .gitlab-ci.yml, tous vos collaborateurs pourraient avoir accès à vos clés.
                                        En tant que variables Gitlab, seul le serveur d'intégration continue connait leurs valeurs.
                                    </p>
                                </div>
                            </div>
                            <br/>
                            <h3 id="gitlab-variables">Variables</h3>
                            <div class="row">
                                <div class="span12">
                                    <p>
                                        Définissez les variables comme ci-dessous :
                                    </p>
                                </div>
                                <div class="span6" style="text-align: center;">
                                    <a class="image-popup" href="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/gitlab-variables.png') }}" target="_blank">
                                        <img src="{{ asset('bundles/anthonykgrossfrmain/images/Articles/gitlab-rancher-docker/gitlab-variables.png') }}" />
                                    </a>
                                    <i>Ajout des variables dans Gitlab</i>
                                </div>
                                <div class="span6">
                                    <pre class="language-yaml"><code>
RANCHER_ACCESS_KEY : MY_RANCHER_ACCESS_KEY
RANCHER_ENV : Default
RANCHER_SECRET_KEY : MY_RANCHER_SECRET_KEY
RANCHER_SERVICE : symfony3_app
RANCHER_STACK : Default
RANCHER_URL : http://yourdomain.com:8080
                                    </code></pre>
                                </div>
                            </div>
                            <br/>
                            <div class="row">
                                <div class="span12">
                                    <p>
                                        Pour ce qui est de <b>RANCHER_ACCESS_KEY</b> et de <b>RANCHER_SECRET_KEY</b> vous l'aurez compris :
                                        elles serviront à se connecter à l’API de Rancher. La variable <b>RANCHER_URL</b> est l’adresse
                                        et le port d'accès à votre serveur, <b>RANCHER_ENV</b> et <b>RANCHER_STACK</b>
                                        sont vraiment spécifiques à notre gestionnaire de containers et à votre configuration. Rappelez vous,
                                        après l’ajout de notre <b>Registry</b>, nous avons ajouté notre machine Mysql dans l’environnement <a class="active-anchor" href="#rancher-services">Default</a>.
                                        Sachez que si vous utilisez Rancher avec la configuration par défaut, la valeur de ces deux variables
                                        sont “<b>Default</b>”. Sinon, à vous de savoir comment remplir ces champs. Enfin, <b>RANCHER_SERVICE</b>
                                        c’est le nom de la machine que vous voulez mettre à jour après chacune des mises à jour de nos
                                        sources; ici “<b>symfony3_app</b>” créée juste avant la génération des identifiants API.
                                    </p>
                                </div>
                            </div>
                            <br/>
                            <h2 id="dernieres-modifications">Dernières modifications</h2>
                            <br/>
                            <h3 id="finalisation-gitlabci">Finalisation de la configuration de GitlabCI</h3>
                            <div class="row">
                                <div class="span12">
                                    <p>
                                        Ça y est, on est à la fin ! Nous n’avons plus qu’à éditer notre fichier
                                        <b>.gitlab-ci.yml</b> et à ajouter dans l'étape “<b>deploy</b>” la commande pour remplacer
                                        notre image Docker par celle que nous venons
                                        juste de créer. Vous savez quoi ? C'est terminé =D
                                    </p>
                                    <pre class="language-yaml"><code>
# .gitlab-ci.yml
...
deploy:
  stage: deploy
  image: cdrx/rancher-gitlab-deploy
  only:
    - master
  script:
    - upgrade --environment $RANCHER_ENV --stack $RANCHER_STACK --service $RANCHER_SERVICE --no-start-before-stopping --no-wait-for-upgrade-to-finish
                                    </code></pre>
                                    <p>
                                        Pour vérifier, ouvrez votre serveur <b>Rancher</b> et allez dans la liste
                                        des services en cours. Une autre fenêtre dans votre navigateur est nécessaire pour
                                        visualiser le lancement de GitlabCI dans votre <b>Gitlab</b> (dans l'onglet <b>Pipeline</b>).
                                        Modifiez les sources de votre projet et poussez les modifications sur la branche <b>Master</b>.
                                        Gitlab reçoit votre commit, lance vos tests unitaires puis signale
                                        à Rancher que celui-ci doit mettre à jour le service dont le nom est
                                        “<b>Symfony3_app</b>”. Regardez sur Rancher, votre service est en cours de
                                        mise à jour, puis de redémarrage et votre nouvelle image est en production.
                                        Bien entendu, si vous avez correctement configuré votre image Docker,
                                        vos noms de domaines, etc … (Tout ce qui vous est propre), vous devriez
                                        voir la nouvelle version de votre site en ligne.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <br/>
            <div class="row">
                <div class="span12">
                    <div class="row">
                        <div class="span12">
                            <h2>Conclusion</h2>
                            <p>
                                Je sais ... Je me suis embarqué dans l'écriture d'un article plutôt indigeste mais il fallait
                                absolument que vous sachiez ! Désormais, vous êtes en mesure de pouvoir faire du déploiement continue automatique
                                sans aucune intervention humaine : directement du producteur au consommateur, et tout ça GRATUITEMENT ! N'hésitez à me le faire savoir si
                                vous avez besoin de davantage d'informations, si vous avez un autre workflow à proposer, toussa toussa !
                                Sur ce, j'ai garé ma baleine en double file. Tchou !
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            <br/>
            <div class="row">
                <div class="span12">
                    <div class="row">
                        <div id="liens-utiles" class="span12">
                            <h3>Liens utiles</h3>
                            <li><a href="https://gitlab.com/anthonykgross/sample-continuous-deployment" target="_blank">Projet Symfony d'exemple</a></li>
                            <li><a href="https://docs.gitlab.com/ce/ci/docker/using_docker_build.html" target="_blank">En avoir plus sur GitlabCI avec Docker</a></li>
                            <li><a href="https://docs.rancher.com/rancher/v1.2/en/installing-rancher/installing-server/" target="_blank">Installation de Rancher</a></li>
                        </div>
                    </div>
                </div>
            </div>
            <br/>
            <div class="meta-desc">
                <i class="fa fa-calendar"></i> &nbsp; Le 14 Novembre 2016 <span class="font-slight"></span>
            </div>
            <br/>
            <div class="fb-comments" data-href="{{ block("og_url") }}" data-numposts="5" data-width="100%"></div>
        </section> <!-- End blog -->
    </div> <!-- End container -->
{% endblock %}